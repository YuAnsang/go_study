# Go 언어
- Go 언어에 대해 학습한다.
- 모든 내용을 정리하는 것이 아니라 개인적으로 생각했을 때, 적어둘 법한 것만 README.md에 작성한다.
- 나머지는 예제 코드를 통해서 진행한다.

## package
- 패키지는 Go 언어에서 코드를 묶는 가장 큰 단위이다.
- 다른 언어에서는 namespace라는 키워드로 코드영역을 분리하기도 하지만 Go는 namespace를 지원하지 않고 패키지를 사용한다.

### main package
- 프로그램 시작점(main())을 포함한 패키지
- 프로그램이 실행되면 운영체제는 프로그램을 메모리로 올린다. (Load라고도 한다.)

### 패키지 사용
```
import "fmt"
imrpot (
    "fmt"
    "math/rand"  // 경로가 있는 패키지 -> 패키지명은 rand
)

import (
    "text/template"
    htemplate "html/template" // template이 겹치므로 별칭    
)
```
- Go 언어는 패캐지를 가져오면 반드시 사용해야 하고 사용하지 않으면 에러가 발생함
- 하지만 아래와 같이 직접 사용하지 않지만 부가효과를 얻고자 하는 경우 _을 붙일수 있음
```
import (
    "database/sql"
    _ "fmt"
)
```

### 패키지 경로
1. Go 언어에서 기본 제공하는 패키지는 Go 설치 경로에서 찾음
2. 외부 저장소에 저장된 패키지의 경우 다운로드 받아서 GOPATH/pkg 폴더에 설치

### Go 모듈
- Go 모듈은 Go 패키지를 모아놓은 프로젝트 단위.
- Go 1.16부터 모듈 사용이 기본으로 됐음. 이전까지는 Go 모듈을 만들지 않는 코드는 모두 GOPATH/src 폴더에 있어야 했지만 이제는 모든 Go코드들이 Go 모듈 아래 있어야함.
- go build를 하려면 반드시 Go 모듈 루트 폴더에 go.mod 파일이 존재해야함.
- Go는 go build를 통해 실행파일을 만들 때, go.mod와 외부 패키지 버전정보를 담고 있는 go.sum 파일을 통해 실행파일을 만들게 됨

## 슬라이스
- 슬라이스는 내장 타입으로 내부 구현이 감춰져 있지만 reflect 패키지의 SliceHeader 구조체를 사용함.
```
type SliceHeader struct {
	Data uintptr // 배열을 가르키는 포인터
	Len  int // 현재 요소의 개수
	Cap  int // 실제 배열의 길이
}
```

### 배열과 슬라이스의 동작 차이
```
func chanceArray(array [5]int) {
    array[2] = 200
}

func chanceSlice(slice2 []int) {
    slice[2] = 200
}

func main() {
  array := [5]int {1, 2, 3, 4, 5}
  slice := []int {1, 2, 3, 4, 5}
  
  changeArray(array) // 동작안함
  changeSlice(slice) // 동작함
}
```
- Go 언어에서 모든 값의 대입은 복사로 일어나고, 함수의 인수로 전달될 때의 값의 이동도 복사로 일어남
- 슬라이스는 포인터, len, cap을 복사하기 때문에 같은 주소값을 가르킴

## 메서드
- Go언어에서는 클래스가 없어서 구조체 밖에서 메서드를 지정함.
- 구조체 밖에 메서드를 정의할 때, 리시버라는 특별한 기능을 사용
- 리시버 : 메서드가 어떤 구조체에 속하는지 표시하는 기법
```
func (r Rabbit) info() int {
	return r.width * r.height
}
```

## 인터페이스
- 구현을 포함하지 않은 메서드의 집합.
- Go언어의 인터페이스는 세가지 유의사항이 존재
  - 메서드는 반드시 메서드명이 있어야함
  - 이름이 같은 메서드는 존재 할 수 없음
  - 구현부는 포함하지 않음
```
type Sample interface {
    String() string
    String(int) string // 에러 -> 메서드명이 겹침
    _(x int) // 에러 메서드명이 존재하지 않음
}
```

## 고루틴
- Go 언어에서 지원하는 경량 스레드
- 기존 OS 스레드에서 발생하는 컨텍스트 스위칭에 따른 성능 손싱을 최소화
- 메모리 간섭으로 인해 발생하는 문제점을 주의할 필요 있음.

### 고루틴의 동작 방법
- 고루틴은 명령을 수행하는 단일 흐름으로 OS스레드를 이용하는 경량 스레드
- 모든 명령은 OS 스레드를 통해 CPU 코어에서 실행
- 아래 예시는 코어가 2개 일 때는 가정
- 고루틴이 하나 일 때
  - 코어 1 ---- OS 스레드 1 ---- 고루틴 1
- 고루틴이 2개 일 때
  - 코어 1 ---- OS 스레드 1 ---- 고루틴 1
  - 코어 2 ---- OS 스레드 2 ---- 고루틴 2
- 고루틴이 2개 일 때
  - 코어 1 ---- OS 스레드 1 ---- 고루틴 1
  - 코어 2 ---- OS 스레드 2 ---- 고루틴 2
  - 고루틴 3은 남은 코어가 생길 때 까지 대기
  - 두 번째 고루틴이 모두 실행 완료되면 고루틴3이 이동
- CPU 코어가 스레드를 변경 하면 컨텍스트 스위칭이 발생하지만 Go 언어는 코어와 스레드는 변경되지 않고 고루틴만 옮겨 다니기 때문에 컨텍스트 스위칭 비용이 발생하지 않음

### 뮤텍스
- 동시성 프로그래밍에서 thread safety가 보장되지 않기 때문에 발생하는 문제가 존재함 (같은 값에 동시에 접근한다던지)
- Go언어에서는 뮤텍스(mutex)를 이용하면 자원 접근 권한을 통제 할 수 있음 (별도 예제 코드 참고)
- 뮤텍스를 사용하면 동시성 프로그래밍은 해결할 수 있지만 데드락 또한 발생 할 수 있음.

### 또 다른 자원 관리 기법
- 동시성 문제는 같은 자원을 여러 고루틴이 접근하기 때문에 발생
- 각 고루틴이 같은 자원에 접근하지 않으면 애시당초 문제가 발생하지 않음
- 각 고루틴이 서로 다른 자원에 접근하는 방법은 두 가지
  - 영역을 나누는 방법
  - 역할을 나누는 방법
- 별도 예제 코드를 참고한다.

## 채널과 컨텍스트
- 채널은 고루틴 간 메시지를 전달하는 메시지큐
- 컨텍스트는 고루틴에 작업을 요청 할 때, 작업 취소나 작업 시간등을 설정 할 수 있는 역할

### 채널
- 채널 인스턴스 생성
```
var messages chan string = make(chan string) // 채널 인스턴스 생성
messages <- "This is a message" // 데이터 push
var msg string = <- messages // 데이터 pop
```
- 일반적으로 채널을 생성하면 버퍼의 크기가 0인 채널이 생성
- 버퍼 크기가 0인 경우 데이터를 빼갈 때 까지 대기함.

### 컨텍스트
- 컨텍스트는 context 패키지에서 제공하는 기능으로 작업을 지시할 때 작업 가능 시간, 작업 취소등을 지시 할 수 있음.